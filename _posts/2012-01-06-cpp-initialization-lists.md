---
title: C++ Initialization Lists
date: 2012-01-06T05:32:00Z
tags: [c++, dev]
---

Все C++ программисты знают, что члены класса можно инициализировать в списке инициализации в конструкторе, но не все хорошо понимают когда члены класса должны получать свои значения в списке инициализации, а когда в теле конструктора. К тому же использование списков инициализации сопряжено с некоторыми тонкостями реализации, пренебрежение которыми может приводить к трудно понимаемым ошибкам.

Чтобы понять разницу в механизме работы списка инициализации и тела конструктора, для начала нужно обратиться к понятиям инициализации и присваивания. _Инициализация_ — это момент получения объектом значения в первый раз. Получение же проинициализированным объектом нового значения является _присваиванием_. Функционально разница между этими понятиями проявляется в том, что при инициализации вызывается конструктор (в том числе конструктор копирования), а при присваивании выполняется `operator=`. Важным моментом является то, что к моменту входа в тело конструктора все члены класса всегда являются проинициализированными, даже если это не указано явно.

Такие члены классов, как ссылки и константы должны получать свои значения в списках инициализации, т.к. они не могут изменять своё значение после инициализации. Объекты классов (не путать с указателями на объекты), конструкторы которых необходимо снабдить параметрами, также необходимо указывать в списке инициализации. Использование списка инициализации может дать также существенный выигрыш в производительности, если его использовать для крупных объектов вместо копирования в теле конструктора.

Если же в классе имеется большое число членов встроенных простых типов (`int`, `double` и др.), то может быть более разумным создать приватный метод, который бы присваивал нужные значения всем таким членам и вызывался во всех конструкторах, где это необходимо. Потеря производительности в этом случае будет ничтожно малой, но при этом улучшится читаемость кода.

Ещё одной очень важной особенностью является то, что порядок инициализации членов класса определяется _только_ порядком их объявления в классе. Эта особенность обусловлена необходимостью уничтожения объектов в деструкторе в правильной (обратной) последовательности, но в различных конструкторах списки инициализации могут содержать члены класса в различном порядке, поэтому для упрощения было принято соглашение о порядке инициализации, идентичном порядку в описании класса.
